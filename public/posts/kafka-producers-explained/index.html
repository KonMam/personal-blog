<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>Kafka Producers Explained: Partitioning, Batching, and Reliability :: mamonas.dev</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Dive into Kafka producers, exploring how they handle message partitioning, serialization, and batching for optimal throughput. Understand delivery guarantees, idempotent producers, and transactional writes for reliable and exactly-once message delivery." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/posts/kafka-producers-explained/" />







  
  
  
  
  
  <link rel="stylesheet" href="http://localhost:1313/styles.css">



<link rel="stylesheet" href="http://localhost:1313/style.css">



  <link rel="shortcut icon" href="http://localhost:1313/img/theme-colors/green.png">
  <link rel="apple-touch-icon" href="http://localhost:1313/img/theme-colors/green.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Kafka Producers Explained: Partitioning, Batching, and Reliability">
<meta property="og:description" content="Dive into Kafka producers, exploring how they handle message partitioning, serialization, and batching for optimal throughput. Understand delivery guarantees, idempotent producers, and transactional writes for reliable and exactly-once message delivery." />
<meta property="og:url" content="http://localhost:1313/posts/kafka-producers-explained/" />
<meta property="og:site_name" content="mamonas.dev" />

  
    <meta property="og:image" content="http://localhost:1313/img/favicon/green.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-08-18 21:39:05 &#43;0300 EEST" />













  


</head>
<body class="green">




<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    mamonas.dev
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/">Home</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/" >Home</a></li>
        
      
    
  </ul>
</nav>

  
  
  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="http://localhost:1313/posts/kafka-producers-explained/">Kafka Producers Explained: Partitioning, Batching, and Reliability</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-08-18</time>
    
</div>

  
    <span class="post-tags">
      
      #<a href="http://localhost:1313/tags/kafka/">kafka</a>&nbsp;
      
      #<a href="http://localhost:1313/tags/producers/">producers</a>&nbsp;
      
      #<a href="http://localhost:1313/tags/messaging/">messaging</a>&nbsp;
      
    </span>
  
  



  

  <div class="post-content"><div>
        <p>A Kafka producer is the entry point for all data written to Kafka. It sends records to specific topic partitions, defines batching behavior, and controls how reliably data is delivered.</p>
<p>This post covers the behaviors and configurations that influence the producer: partitioning, batching, delivery guarantees, and message structure.</p>
<hr>
<h2 id="what-does-a-kafka-producer-do">What Does a Kafka Producer Do?<a href="#what-does-a-kafka-producer-do" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>A Kafka producer is a client library integrated into applications to write messages to Kafka topics. When a message is sent, the producer determines:</p>
<ul>
<li>Which partition the message should go to</li>
<li>How to serialize the message for Kafka</li>
<li>Whether to batch it with others</li>
<li>How many acknowledgments are required before the message is considered delivered</li>
</ul>
<p>Producers are designed to balance speed, reliability, ordering, and throughput. Optimizing for one might require to compromise another.</p>
<hr>
<h2 id="partitioning-strategies-routing-messages-to-partitions">Partitioning Strategies: Routing Messages to Partitions<a href="#partitioning-strategies-routing-messages-to-partitions" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Kafka topics are split into partitions. Every message sent by a producer is written to one partition. This decision is made by a partitioner function.</p>
<h3 id="with-a-key">With a Key<a href="#with-a-key" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>If a message has a key, Kafka hashes it using the Murmur2 algorithm and assigns the message to a partition using:</p>
<pre tabindex="0"><code>partition = hash(key) % number_of_partitions
</code></pre><p>This ensures all messages with the same key go to the same partition. Kafka guarantees message order within a partition, so key-based partitioning is how per-key ordering is maintained.</p>
<h3 id="without-a-key">Without a Key<a href="#without-a-key" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>If the key is null, Kafka uses one of two strategies:</p>
<ul>
<li><strong>Round-robin</strong>: messages cycle through partitions in order. Used in older clients</li>
<li><strong>Sticky partitioning</strong>: the producer sends all messages to the same partition until the batch is sent, then picks a new one. Default in modern clients</li>
</ul>
<p>Sticky partitioning improves batching efficiency while maintaining fair distribution over time.</p>
<hr>
<h2 id="message-format-structure-and-serialization">Message Format: Structure and Serialization<a href="#message-format-structure-and-serialization" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Kafka treats every message as a set of bytes. Each record includes:</p>
<ul>
<li>Key (optional): used for partitioning. Serialized to bytes</li>
<li>Value: the actual data payload. Serialized to bytes</li>
<li>Headers (optional): metadata as key-value pairs</li>
<li>Timestamp: assigned by the client or broker</li>
<li>Partition + Offset: assigned by the broker after the message is stored</li>
</ul>
<p>Kafka does not interpret or modify message content; it just stores and transmits byte arrays. Producers are responsible for serializing messages before sending them.</p>
<p><strong>Example (Python):</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>producer <span style="color:#f92672">=</span> KafkaProducer(value_serializer<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> v: json<span style="color:#f92672">.</span>dumps(v)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))
</span></span></code></pre></div><p>Efficient serialization improves throughput and reduces broker load. Avoid inefficient formats like uncompressed JSON unless specifically required by system constraints.</p>
<hr>
<h2 id="batching-and-compression-optimizing-throughput">Batching and Compression: Optimizing Throughput<a href="#batching-and-compression-optimizing-throughput" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Sending one message per request is inefficient. Kafka producers batch multiple records together per partition before sending them to the broker.</p>
<h3 id="key-configuration-options">Key Configuration Options<a href="#key-configuration-options" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li><code>batch.size</code>: maximum size in bytes for a batch. Larger batches improve compression and throughput, but increase memory usage</li>
<li><code>linger.ms</code>: how long to wait before sending a batch, even if it is not full. Increases batching opportunities at the cost of latency</li>
<li><code>compression.type</code>: compresses full batches. Options include <code>gzip</code>, <code>lz4</code>, <code>snappy</code>, <code>zstd</code></li>
</ul>
<p>The <code>send()</code> method is non-blocking. It queues the record in memory and returns immediately. The background sender thread flushes batches when <code>batch.size</code> is reached or <code>linger.ms</code> expires.</p>
<p>Batching operates on a per-partition basis. As a result, applications that produce to a large number of partitions may experience reduced batching efficiency unless message flow is concentrated across fewer partitions.</p>
<hr>
<h2 id="delivery-guarantees-configuring-reliability-and-ordering">Delivery Guarantees: Configuring Reliability and Ordering<a href="#delivery-guarantees-configuring-reliability-and-ordering" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Kafka producers can trade reliability for speed using the <code>acks</code> configuration:</p>
<ul>
<li><code>acks=0</code>: fire and forget. Fastest, but data may be lost</li>
<li><code>acks=1</code>: wait for leader. Reasonable balance for many use cases</li>
<li><code>acks=all</code>: wait for all in-sync replicas. Safest, with higher latency</li>
</ul>
<h3 id="ordering-and-retries">Ordering and Retries<a href="#ordering-and-retries" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Kafka guarantees ordering within a single partition. To maintain strict ordering, ensure:</p>
<ul>
<li>All related messages share the same key</li>
<li><code>max.in.flight.requests.per.connection &lt;= 1</code> when retries are enabled (to prevent out-of-order writes during retries)</li>
</ul>
<hr>
<h2 id="idempotence-and-transactions">Idempotence and Transactions<a href="#idempotence-and-transactions" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>By default, producers use at-least-once semantics, meaning retries may cause duplicate messages. Kafka provides stronger guarantees where needed.</p>
<h3 id="idempotent-producer">Idempotent Producer<a href="#idempotent-producer" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Enable with <code>enable.idempotence=true</code>. This prevents duplicates during retries by assigning each producer a unique ID and tracking sequence numbers per partition.</p>
<p>This guarantees exactly-once delivery per partition, assuming the producer does not crash and restart with a new ID.</p>
<p><strong>Use this when:</strong></p>
<ul>
<li>Downstream systems cannot deduplicate</li>
<li>Every message must be uniquely written (for example, financial systems)</li>
</ul>
<p>Avoid using high <code>max.in.flight</code> values with idempotence if ordering matters.</p>
<h3 id="transactional-producer">Transactional Producer<a href="#transactional-producer" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Transactional producers enable atomic writes across multiple partitions or topics.</p>
<p><strong>Requires:</strong></p>
<ul>
<li>A configured <code>transactional.id</code></li>
<li>Use of API methods: <code>begin_transaction()</code>, <code>send()</code>, <code>commit_transaction()</code></li>
</ul>
<p>This is critical for:</p>
<ul>
<li>Exactly-once event processing pipelines</li>
<li>Kafka Streams applications</li>
<li>Coordinating multiple topic writes as a single atomic unit</li>
</ul>
<p>Transactions ensure no duplicates, no partial writes, and consistent failure handling.</p>
<hr>
<h2 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>A well-tuned Kafka producer is critical to balancing throughput, reliability, and resource efficiency. It&rsquo;s important to understand your delivery requirements and system constraints before leaning into aggressive batching or strong guarantees as you trade higher throughput for it.</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    <div class="copyright">
      <ul>
        <li>© 2025 mamonas.dev</li>
        <li><a href="https://www.linkedin.com/in/konstantinas-mamonas" target="_blank" class="social-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
              <path d="M22.23 0H1.77C.79 0 0 .77 0 1.72v20.56C0 23.23.79 24 1.77 24h20.46c.98 0 1.77-.77 1.77-1.72V1.72C24 .77 23.21 0 22.23 0zM7.06 20.45h-3.5V8.9h3.5v11.55zM5.31 7.42c-1.15 0-2.08-.93-2.08-2.08s.93-2.08 2.08-2.08 2.08.93 2.08 2.08-.93 2.08-2.08 2.08zm15.14 13.03h-3.5v-5.5c0-1.31-.02-3-1.82-3-1.83 0-2.11 1.43-2.11 2.9v5.6h-3.5V8.9h3.36v1.54h.05c.47-.89 1.62-1.82 3.31-1.82 3.53 0 4.18 2.32 4.18 5.33v6.1z"/>
          </svg>
        </a></li>
        <li><a href="https://github.com/KonMam" target="_blank" class="social-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-github" viewBox="0 0 16 16">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8"/>
          </svg>
        </a></li>
      </ul>
    </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>







  
</div>

</body>
</html>
